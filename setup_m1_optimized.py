#!/usr/bin/env python3
"""
M1 MacBook Air Setup Script for Optimized RAG System
Installs and configures the system for optimal performance on 8GB RAM M1 MacBook Air
"""

import os
import sys
import subprocess
import platform
from pathlib import Path

def check_system_compatibility():
    """Check if system is compatible"""
    print("üîç Checking system compatibility...")
    
    system_info = {
        "platform": platform.system(),
        "machine": platform.machine(),
        "python_version": sys.version_info
    }
    
    print(f"   Platform: {system_info['platform']}")
    print(f"   Architecture: {system_info['machine']}")
    print(f"   Python: {system_info['python_version'].major}.{system_info['python_version'].minor}")
    
    # Check for M1/M2 Mac
    is_apple_silicon = (
        system_info["platform"] == "Darwin" and 
        system_info["machine"] == "arm64"
    )
    
    if is_apple_silicon:
        print("‚úÖ Apple Silicon Mac detected - optimizations will be applied")
    else:
        print("‚ö†Ô∏è  Not an Apple Silicon Mac - some optimizations may not apply")
    
    # Check Python version
    if system_info["python_version"] < (3, 8):
        print("‚ùå Python 3.8+ required")
        return False
    
    return True

def install_optimized_dependencies():
    """Install M1-optimized dependencies"""
    print("\nüì¶ Installing M1-optimized dependencies...")
    
    # Check if we're in a virtual environment
    in_venv = hasattr(sys, 'real_prefix') or (
        hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix
    )
    
    if not in_venv:
        print("‚ö†Ô∏è  Warning: Not in a virtual environment. Consider creating one:")
        print("   python -m venv venv")
        print("   source venv/bin/activate  # On macOS/Linux")
        response = input("Continue anyway? (y/N): ")
        if response.lower() != 'y':
            return False
    
    try:
        # Upgrade pip first
        subprocess.run([sys.executable, "-m", "pip", "install", "--upgrade", "pip"], check=True)
        
        # Install from optimized requirements
        requirements_file = "requirements_optimized.txt"
        if os.path.exists(requirements_file):
            print(f"   Installing from {requirements_file}...")
            subprocess.run([
                sys.executable, "-m", "pip", "install", 
                "-r", requirements_file
            ], check=True)
        else:
            print(f"   {requirements_file} not found, installing core dependencies...")
            core_deps = [
                "torch==2.3.0",
                "torchvision==0.18.0", 
                "torchaudio==2.3.0",
                "langchain==0.1.20",
                "langchain-community==0.0.38",
                "langchain-groq==0.1.5",
                "sentence-transformers==2.7.0",
                "faiss-cpu==1.8.0",
                "python-telegram-bot==21.3",
                "numpy==1.26.4"
            ]
            
            for dep in core_deps:
                print(f"   Installing {dep}...")
                subprocess.run([sys.executable, "-m", "pip", "install", dep], check=True)
        
        print("‚úÖ Dependencies installed successfully")
        return True
        
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Failed to install dependencies: {e}")
        return False

def setup_directories():
    """Setup required directories"""
    print("\nüìÅ Setting up directories...")
    
    directories = [
        "logs",
        "faiss_index", 
        "data",
        "cache"
    ]
    
    for directory in directories:
        Path(directory).mkdir(exist_ok=True)
        print(f"   ‚úÖ {directory}/")
    
    return True

def create_optimized_config():
    """Create optimized configuration file"""
    print("\n‚öôÔ∏è  Creating optimized configuration...")
    
    config_content = """# M1 MacBook Air Optimized Configuration
# Generated by setup_m1_optimized.py

# Device Configuration
DEVICE = "mps"  # Use Metal Performance Shaders on M1
FALLBACK_DEVICE = "cpu"

# Memory Optimization (8GB RAM)
MAX_DOCS_FOR_RETRIEVAL = 8
MAX_DOCS_FOR_CONTEXT = 4
CONTEXT_CHUNK_SIZE = 1200
BATCH_SIZE_EMBEDDING = 16
BATCH_SIZE_CROSS_ENCODER = 8

# Model Configuration
EMBEDDING_MODEL = "sentence-transformers/all-MiniLM-L6-v2"  # Smaller, faster
CROSS_ENCODER_MODEL = "cross-encoder/ms-marco-MiniLM-L-2-v1"  # Lightweight
GROQ_MODEL = "llama3-8b-8192"

# Performance Settings
CACHE_SIZE = 100
CACHE_TTL = 86400  # 24 hours
THREAD_COUNT = 4  # M1 performance cores

# Relevance Thresholds
RELEVANCE_THRESHOLD = 0.15
SEMANTIC_SIMILARITY_THRESHOLD = 0.3
VALIDATION_CONFIDENCE_THRESHOLD = 0.3

# Environment Variables for M1
import os
os.environ.update({
    "TOKENIZERS_PARALLELISM": "false",
    "OMP_NUM_THREADS": "4",
    "MKL_NUM_THREADS": "4",
    "VECLIB_MAXIMUM_THREADS": "4",
    "PYTORCH_MPS_HIGH_WATERMARK_RATIO": "0.0",
    "PYTORCH_ENABLE_MPS_FALLBACK": "1"
})
"""
    
    with open("m1_config.py", "w") as f:
        f.write(config_content)
    
    print("   ‚úÖ m1_config.py created")
    return True

def verify_installation():
    """Verify the installation"""
    print("\nüîç Verifying installation...")
    
    try:
        # Test PyTorch MPS
        import torch
        print(f"   PyTorch version: {torch.__version__}")
        
        if torch.backends.mps.is_available():
            print("   ‚úÖ MPS (Metal Performance Shaders) available")
            
            # Test MPS functionality
            x = torch.randn(10, 10)
            if torch.backends.mps.is_built():
                x_mps = x.to('mps')
                print("   ‚úÖ MPS tensor operations working")
        else:
            print("   ‚ö†Ô∏è  MPS not available, will use CPU")
        
        # Test other key imports
        import langchain
        print(f"   LangChain version: {langchain.__version__}")
        
        import sentence_transformers
        print(f"   Sentence Transformers version: {sentence_transformers.__version__}")
        
        import faiss
        print("   ‚úÖ FAISS available")
        
        print("‚úÖ All core components verified")
        return True
        
    except ImportError as e:
        print(f"‚ùå Import error: {e}")
        return False
    except Exception as e:
        print(f"‚ùå Verification error: {e}")
        return False

def create_run_script():
    """Create optimized run script"""
    print("\nüìù Creating run script...")
    
    run_script = """#!/usr/bin/env python3
# M1 Optimized RAG System Runner

import sys
import os

# Add current directory to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Apply M1 optimizations
from m1_optimization import optimize_for_m1
optimizer = optimize_for_m1()

# Import and run the optimized main
try:
    from optimized_main import OptimizedFinancialAdvisorBot
    print("üöÄ Starting M1-optimized RAG system...")
    
    # Run the bot
    if __name__ == "__main__":
        import asyncio
        from optimized_main import *
        
        # Start the bot with optimizations
        token = os.getenv("TELEGRAM_TOKEN", "7596897324:AAG3TsT18amwRF2nRBcr1JS6NdGs96Ie-D0")
        
        print("[INFO] üöÄ Starting M1-Optimized Financial Advisor Bot...")
        print(f"[INFO] üíª Device: {optimizer.get_optimal_device()}")
        print(f"[INFO] üß† Memory Available: {optimizer.monitor_memory_usage()['available_gb']:.1f}GB")
        
        app = ApplicationBuilder().token(token).build()
        app.add_handler(CommandHandler("start", start))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_query))
        
        print("[INFO] ‚úÖ M1-Optimized Bot is ready and polling...")
        app.run_polling()
        
except ImportError as e:
    print(f"‚ùå Failed to import optimized components: {e}")
    print("üí° Falling back to original main.py...")
    
    try:
        from main import *
        # Run original version
        if __name__ == "__main__":
            # Apply basic optimizations
            import torch
            torch.set_num_threads(4)
            
            # Run original bot
            exec(open("main.py").read())
    except Exception as e2:
        print(f"‚ùå Failed to run fallback: {e2}")
        sys.exit(1)
"""
    
    with open("run_optimized.py", "w") as f:
        f.write(run_script)
    
    # Make executable
    os.chmod("run_optimized.py", 0o755)
    
    print("   ‚úÖ run_optimized.py created")
    return True

def main():
    """Main setup function"""
    print("üöÄ M1 MacBook Air RAG System Setup")
    print("=" * 50)
    
    # Step 1: Check compatibility
    if not check_system_compatibility():
        print("‚ùå System compatibility check failed")
        return False
    
    # Step 2: Install dependencies
    if not install_optimized_dependencies():
        print("‚ùå Dependency installation failed")
        return False
    
    # Step 3: Setup directories
    if not setup_directories():
        print("‚ùå Directory setup failed")
        return False
    
    # Step 4: Create configuration
    if not create_optimized_config():
        print("‚ùå Configuration creation failed")
        return False
    
    # Step 5: Verify installation
    if not verify_installation():
        print("‚ùå Installation verification failed")
        return False
    
    # Step 6: Create run script
    if not create_run_script():
        print("‚ùå Run script creation failed")
        return False
    
    print("\n" + "=" * 50)
    print("‚úÖ M1 MacBook Air RAG System Setup Complete!")
    print("\nüìã Next Steps:")
    print("1. Ensure your FAISS index is in the faiss_index/ directory")
    print("2. Update your Groq API key in the configuration")
    print("3. Run the optimized system:")
    print("   python run_optimized.py")
    print("\nüí° Tips:")
    print("‚Ä¢ Monitor memory usage with Activity Monitor")
    print("‚Ä¢ Close other applications for best performance")
    print("‚Ä¢ The system is optimized for 8GB RAM usage")
    
    return True

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
